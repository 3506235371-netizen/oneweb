<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS/Android Web App 模式 (全屏体验) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f172a">

    <title>霓虹相扑：核心争夺战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 全局禁止选中和触摸默认行为 */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            -webkit-user-select: none;
        }

        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* 关键：禁止浏览器处理手势 */
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 20px rgba(255, 255, 255, 0.3);
        }

        /* 强制横屏提示 UI */
        #orientation-lock {
            display: none;
        }
        
        /* 仅在竖屏时显示旋转提示 */
        @media screen and (orientation: portrait) {
            #orientation-lock {
                display: flex;
            }
            #game-layer {
                display: none;
            }
        }
    </style>
</head>
<body class="w-full h-full text-white">

    <!-- 竖屏时的强制旋转提示 -->
    <div id="orientation-lock" class="fixed inset-0 z-50 bg-slate-900 flex flex-col items-center justify-center p-6 text-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-24 w-24 mb-6 animate-pulse text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
        </svg>
        <h2 class="text-3xl font-bold mb-3 text-white">请旋转手机</h2>
        <p class="text-slate-400 text-lg">游戏仅支持横屏双人对战</p>
    </div>

    <!-- 游戏层 -->
    <div id="game-layer" class="relative w-full h-full overflow-hidden bg-slate-900">
        
        <!-- Canvas -->
        <canvas id="gameCanvas" class="absolute top-0 left-0 block touch-none"></canvas>

        <!-- UI 层 -->
        <div class="absolute top-0 left-0 w-full h-full pointer-events-none flex justify-between items-start p-4 md:p-6 z-10">
            <!-- P1 分数 -->
            <div class="flex flex-col items-start">
                <div class="text-blue-500 font-bold text-lg md:text-xl tracking-wider uppercase opacity-80">Player 1</div>
                <div id="score-p1" class="text-5xl md:text-6xl font-black neon-text text-blue-400">0</div>
            </div>

            <!-- 游戏消息 -->
            <div id="game-message" class="mt-4 text-2xl md:text-3xl font-bold opacity-0 transition-opacity duration-200 bg-black/60 px-6 py-2 rounded-full backdrop-blur-md border border-white/10">
                READY
            </div>

            <!-- P2 分数 -->
            <div class="flex flex-col items-end">
                <div class="text-red-500 font-bold text-lg md:text-xl tracking-wider uppercase opacity-80">Player 2</div>
                <div id="score-p2" class="text-5xl md:text-6xl font-black neon-text text-red-400">0</div>
            </div>
        </div>

        <!-- 主菜单 / 暂停层 -->
        <div id="menu-overlay" class="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center z-20 backdrop-blur-md transition-all duration-500">
            <h1 class="text-6xl md:text-8xl font-black mb-2 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 via-white to-red-400 neon-text italic tracking-tighter" style="filter: drop-shadow(0 0 15px rgba(59,130,246,0.5)); transform: skewX(-10deg);">
                NEON SUMO
            </h1>
            <p class="text-slate-300 mb-10 text-lg tracking-widest font-light uppercase border-b border-slate-600 pb-2">Mobile Core Battle</p>
            
            <div class="flex w-full max-w-2xl justify-center gap-12 mb-12 opacity-80">
                <div class="flex flex-col items-center gap-2">
                    <div class="w-16 h-16 rounded-full border-4 border-blue-500 flex items-center justify-center bg-blue-500/10 animate-pulse">
                        <div class="w-4 h-4 bg-blue-400 rounded-full"></div>
                    </div>
                    <span class="text-sm font-bold text-blue-400">左侧区域</span>
                    <span class="text-xs text-slate-500">任意位置拖动</span>
                </div>
                <div class="h-20 w-px bg-slate-700 mx-4"></div>
                <div class="flex flex-col items-center gap-2">
                    <div class="w-16 h-16 rounded-full border-4 border-red-500 flex items-center justify-center bg-red-500/10 animate-pulse" style="animation-delay: 0.5s;">
                        <div class="w-4 h-4 bg-red-400 rounded-full"></div>
                    </div>
                    <span class="text-sm font-bold text-red-400">右侧区域</span>
                    <span class="text-xs text-slate-500">任意位置拖动</span>
                </div>
            </div>

            <button id="start-btn" class="group relative px-12 py-5 bg-white text-slate-900 rounded-full text-2xl font-bold transition-transform active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.3)] overflow-hidden">
                <span class="relative z-10">开始对战</span>
                <div class="absolute inset-0 bg-gradient-to-r from-blue-400 to-red-400 opacity-0 group-hover:opacity-20 transition-opacity"></div>
            </button>
            <p class="mt-6 text-slate-500 text-xs">推荐将网页添加到主屏幕以获得最佳体验</p>
        </div>
    </div>

<script>
/**
 * Neon Sumo: Mobile Optimized Version
 * 使用 Pointer Events 替代 Touch Events 以获得更好的兼容性
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // 优化性能
const menuOverlay = document.getElementById('menu-overlay');
const startBtn = document.getElementById('start-btn');
const scoreElP1 = document.getElementById('score-p1');
const scoreElP2 = document.getElementById('score-p2');
const msgEl = document.getElementById('game-message');

// 游戏常量
const PHYSICS = {
    FRICTION: 0.92,
    ACCELERATION: 1.5,
    MAX_SPEED: 14,
    PLAYER_RADIUS: 28,
    REBOUND: 1.3,
    MASS: 10
};

// 状态管理
let gameState = 'MENU'; // MENU, PLAYING, ROUND_OVER
let animationId;
let lastTime = 0;
let width, height, centerX, centerY;
let arena = { radius: 100, maxRadius: 100, minRadius: 10, shrinkRate: 0.35 };
let particles = [];

// 玩家数据模型
class Player {
    constructor(id, color, glowColor, startSide) {
        this.id = id;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.radius = PHYSICS.PLAYER_RADIUS;
        this.color = color;
        this.glow = glowColor;
        this.score = 0;
        this.startSide = startSide; // -1 for left, 1 for right
        
        // 输入状态
        this.pointerId = null; // 绑定的指针ID
        this.joystick = {
            active: false,
            originX: 0, originY: 0,
            curX: 0, curY: 0
        };
    }

    resetPosition() {
        this.vx = 0;
        this.vy = 0;
        this.x = centerX + (this.startSide * arena.maxRadius * 0.5);
        this.y = centerY;
        this.pointerId = null;
        this.joystick.active = false;
    }
}

const p1 = new Player(1, '#3b82f6', '#60a5fa', -1); // Blue, Left
const p2 = new Player(2, '#ef4444', '#f87171', 1);  // Red, Right

// --- 系统初始化 ---

function resize() {
    // 动态获取视口大小，解决移动端地址栏问题
    width = window.innerWidth;
    height = window.innerHeight;

    // 防止在视口为0时（如初始化瞬间）崩溃
    if (width === 0 || height === 0) return;
    
    // 设置 Canvas 分辨率
    canvas.width = width;
    canvas.height = height;
    
    // 逻辑中心
    centerX = width / 2;
    centerY = height / 2;

    // 竞技场参数 - 修复可能的负数半径错误
    const rawRadius = Math.min(width, height) / 2 - 25;
    arena.maxRadius = Math.max(rawRadius, 50); // 确保最小有50px，防止 crash
    arena.minRadius = PHYSICS.PLAYER_RADIUS * 2.2;
    
    // 确保最小半径合理
    if (arena.minRadius >= arena.maxRadius) {
        arena.minRadius = arena.maxRadius * 0.5;
    }
    
    if (gameState === 'MENU') {
        p1.resetPosition();
        p2.resetPosition();
        arena.radius = arena.maxRadius;
        drawFrame();
    }
}

// 监听旋转和调整大小
window.addEventListener('resize', resize);
// 初始调用
resize();

// --- 指针输入处理 (核心) ---

// 禁止右键菜单
canvas.addEventListener('contextmenu', e => e.preventDefault());

function handlePointerDown(e) {
    e.preventDefault();
    
    // 如果已经在控制中，忽略新的点击（防止一个玩家多指触控导致鬼畜）
    if (p1.pointerId === e.pointerId || p2.pointerId === e.pointerId) return;

    const x = e.clientX;
    const y = e.clientY;

    // 简单的屏幕分割逻辑
    let targetPlayer = null;
    
    // 左半屏 -> P1
    if (x < width / 2) {
        if (p1.pointerId === null) targetPlayer = p1;
    } 
    // 右半屏 -> P2
    else {
        if (p2.pointerId === null) targetPlayer = p2;
    }

    if (targetPlayer) {
        targetPlayer.pointerId = e.pointerId;
        targetPlayer.joystick.active = true;
        targetPlayer.joystick.originX = x;
        targetPlayer.joystick.originY = y;
        targetPlayer.joystick.curX = x;
        targetPlayer.joystick.curY = y;
    }
}

function handlePointerMove(e) {
    e.preventDefault();
    // 更新对应玩家的摇杆位置
    if (p1.pointerId === e.pointerId) {
        p1.joystick.curX = e.clientX;
        p1.joystick.curY = e.clientY;
    } else if (p2.pointerId === e.pointerId) {
        p2.joystick.curX = e.clientX;
        p2.joystick.curY = e.clientY;
    }
}

function handlePointerUp(e) {
    e.preventDefault();
    if (p1.pointerId === e.pointerId) {
        p1.pointerId = null;
        p1.joystick.active = false;
    } else if (p2.pointerId === e.pointerId) {
        p2.pointerId = null;
        p2.joystick.active = false;
    }
}

// 绑定 Pointer Events (兼容 Mouse 和 Touch)
canvas.addEventListener('pointerdown', handlePointerDown);
canvas.addEventListener('pointermove', handlePointerMove);
canvas.addEventListener('pointerup', handlePointerUp);
canvas.addEventListener('pointercancel', handlePointerUp);
canvas.addEventListener('pointerout', handlePointerUp);


// --- 游戏循环逻辑 ---

function startGame() {
    gameState = 'PLAYING';
    menuOverlay.classList.add('opacity-0', 'pointer-events-none');
    
    // 重置数据
    resize(); 
    p1.resetPosition();
    p2.resetPosition();
    arena.radius = arena.maxRadius;
    particles = [];
    
    // 进入全屏 (如果允许)
    try {
        if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen().catch(() => {});
        }
    } catch(e) {}

    showMessage("FIGHT!", 1200);
    
    lastTime = performance.now();
    cancelAnimationFrame(animationId);
    gameLoop(lastTime);
}

function resetGame() {
    p1.score = 0;
    p2.score = 0;
    updateScores();
    startGame();
}

function showMessage(text, duration = 1000) {
    msgEl.innerHTML = text;
    msgEl.classList.remove('opacity-0');
    setTimeout(() => {
        msgEl.classList.add('opacity-0');
    }, duration);
}

function updateScores() {
    scoreElP1.innerText = p1.score;
    scoreElP2.innerText = p2.score;
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 12; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: Math.random() * 0.03 + 0.02,
            color: color
        });
    }
}

function updatePhysics() {
    // 缩圈
    if (arena.radius > arena.minRadius) {
        arena.radius -= arena.shrinkRate;
    }

    [p1, p2].forEach(p => {
        // 摇杆力
        if (p.joystick.active) {
            const dx = p.joystick.curX - p.joystick.originX;
            const dy = p.joystick.curY - p.joystick.originY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > 0) {
                const angle = Math.atan2(dy, dx);
                const force = Math.min(dist / 60, 1.0); // 摇杆灵敏度
                p.vx += Math.cos(angle) * PHYSICS.ACCELERATION * force;
                p.vy += Math.sin(angle) * PHYSICS.ACCELERATION * force;
            }
        }

        // 摩擦力和限速
        p.vx *= PHYSICS.FRICTION;
        p.vy *= PHYSICS.FRICTION;
        const speed = Math.sqrt(p.vx**2 + p.vy**2);
        if (speed > PHYSICS.MAX_SPEED) {
            p.vx = (p.vx / speed) * PHYSICS.MAX_SPEED;
            p.vy = (p.vy / speed) * PHYSICS.MAX_SPEED;
        }

        p.x += p.vx;
        p.y += p.vy;
    });

    // 玩家碰撞检测
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const minDist = p1.radius + p2.radius;

    if (dist < minDist) {
        // 碰撞响应
        const angle = Math.atan2(dy, dx);
        const tx = Math.cos(angle);
        const ty = Math.sin(angle);

        // 分离位置
        const overlap = (minDist - dist) * 0.5;
        p1.x -= tx * overlap;
        p1.y -= ty * overlap;
        p2.x += tx * overlap;
        p2.y += ty * overlap;

        // 弹性碰撞计算
        const v1n = p1.vx * tx + p1.vy * ty;
        const v2n = p2.vx * tx + p2.vy * ty;

        // 动量交换 + 弹力增强
        const v1nFinal = v2n * PHYSICS.REBOUND;
        const v2nFinal = v1n * PHYSICS.REBOUND;

        p1.vx += (v1nFinal - v1n) * tx;
        p1.vy += (v1nFinal - v1n) * ty;
        p2.vx += (v2nFinal - v2n) * tx;
        p2.vy += (v2nFinal - v2n) * ty;

        // 特效
        createExplosion((p1.x+p2.x)/2, (p1.y+p2.y)/2, '#fff');
    }

    // 出界检测
    const checkOut = (p, opponent) => {
        const d = Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2);
        if (d > arena.radius + p.radius) {
            endRound(opponent);
        }
    };
    
    checkOut(p1, p2);
    if(gameState === 'PLAYING') checkOut(p2, p1);
}

function endRound(winner) {
    if (gameState === 'ROUND_OVER') return;
    gameState = 'ROUND_OVER';
    
    winner.score++;
    updateScores();
    
    const colorClass = winner === p1 ? 'text-blue-400' : 'text-red-400';
    const name = winner === p1 ? 'BLUE' : 'RED';
    showMessage(`<span class="${colorClass}">${name} WINS!</span>`, 2000);
    
    createExplosion(winner.x, winner.y, winner.color);

    setTimeout(() => {
        if (gameState !== 'MENU') {
            p1.resetPosition();
            p2.resetPosition();
            arena.radius = arena.maxRadius;
            gameState = 'PLAYING';
        }
    }, 2000);
}

// --- 渲染逻辑 ---

function drawJoystick(p) {
    if (!p.joystick.active) return;
    
    // 底盘
    ctx.beginPath();
    ctx.arc(p.joystick.originX, p.joystick.originY, 45, 0, Math.PI*2);
    ctx.strokeStyle = `rgba(255,255,255,0.15)`;
    ctx.lineWidth = 3;
    ctx.stroke();

    // 摇杆头
    ctx.beginPath();
    ctx.arc(p.joystick.curX, p.joystick.curY, 25, 0, Math.PI*2);
    ctx.fillStyle = `rgba(255,255,255,0.4)`;
    ctx.fill();
}

function drawPlayer(p) {
    // 阴影优化：不要每帧都设置 shadowBlur，消耗大，用 Canvas 渐变模拟或减少频率
    // 这里为了视觉效果保留，但在低端机可能卡顿
    ctx.shadowColor = p.glow;
    ctx.shadowBlur = 20;

    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.shadowBlur = 0; // 重置

    // 内部光泽
    ctx.beginPath();
    ctx.arc(p.x - p.radius*0.3, p.y - p.radius*0.3, p.radius*0.4, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fill();

    // 方向指示
    const speed = Math.sqrt(p.vx**2 + p.vy**2);
    if (speed > 1) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(Math.atan2(p.vy, p.vx));
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-4, 5);
        ctx.lineTo(-4, -5);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
        ctx.restore();
    }
}

function drawFrame() {
    // 安全检查，如果尺寸不合法则不渲染
    if (!width || !height) return;
    
    // 背景清除 & 动态背景
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, width, height);

    // 网格线
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    const step = 60;
    ctx.beginPath();
    for(let x=0; x<width; x+=step) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=0; y<height; y+=step) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
    ctx.stroke();

    // 中线
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, height);
    ctx.setLineDash([10, 15]);
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.setLineDash([]);

    // 竞技场圈
    // 关键修复：确保半径为正数，否则 arc 会报错
    if (arena.radius > 0) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, arena.radius, 0, Math.PI*2);
        
        // 危险预警颜色
        const dangerRatio = (arena.radius - arena.minRadius) / (arena.maxRadius - arena.minRadius);
        if (dangerRatio < 0.3) {
            ctx.strokeStyle = `rgba(255, 50, 50, ${0.5 + Math.random()*0.5})`; // 闪烁
            ctx.shadowColor = 'red';
            ctx.shadowBlur = 15;
        } else {
            ctx.strokeStyle = 'white';
            ctx.shadowColor = 'cyan';
            ctx.shadowBlur = 10;
        }
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // 圈外阴影 (蒙版)
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        ctx.arc(centerX, centerY, arena.radius, 0, Math.PI*2, true);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fill();
    }

    // 粒子
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= p.decay;
        p.x += p.vx;
        p.y += p.vy;
        if (p.life <= 0) {
            particles.splice(i, 1);
        } else {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.random()*3 + 1, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    drawPlayer(p1);
    drawPlayer(p2);
    drawJoystick(p1);
    drawJoystick(p2);
}

function gameLoop(timestamp) {
    if (gameState !== 'MENU') {
        if (gameState === 'PLAYING') updatePhysics();
        drawFrame();
        animationId = requestAnimationFrame(gameLoop);
    }
}

// 启动按钮
startBtn.addEventListener('click', resetGame);
// 兼容性：某些移动浏览器 click 有延迟，加上 touchstart
startBtn.addEventListener('touchstart', (e) => {
    e.preventDefault(); // 防止触发 click
    resetGame();
}, { passive: false });

</script>
</body>
</html>